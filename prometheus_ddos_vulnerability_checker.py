#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Prometheus DoS Vulnerability Checker
-----------------------------------

Esta ferramenta verifica se uma instância Prometheus é suscetível a ataques de
negação de serviço através de endpoints que consomem muitos recursos, como
o endpoint de heap profiling.

AVISO: Esta ferramenta NÃO realiza ataques DoS. Ela apenas verifica a suscetibilidade 
a esses ataques executando um teste leve e monitorando a resposta.

Autor: [Seu nome]
Versão: 1.1
"""

import argparse
import concurrent.futures
import requests
import time
import sys
import socket
import logging
from urllib.parse import urlparse
import json

# Cores ANSI simples para terminal (sem dependência externa)
# Cores podem ser desativadas com --no-color
COLOR_RED = "\033[91m"
COLOR_GREEN = "\033[92m"
COLOR_YELLOW = "\033[93m"
COLOR_BLUE = "\033[94m"
COLOR_RESET = "\033[0m"

# Banner da ferramenta
BANNER = """
╔════════════════════════════════════════════════════════════╗
║                                                            ║
║  ██████╗ ██████╗  ██████╗ ███╗   ███╗ ██████╗██╗  ██╗      ║
║  ██╔══██╗██╔══██╗██╔═══██╗████╗ ████║██╔════╝██║  ██║      ║
║  ██████╔╝██████╔╝██║   ██║██╔████╔██║███████╗███████║      ║
║  ██╔═══╝ ██╔══██╗██║   ██║██║╚██╔╝██║██╔═══██║██╔══██║      ║
║  ██║     ██║  ██║╚██████╔╝██║ ╚═╝ ██║╚██████╔╝██║  ██║      ║
║  ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝      ║
║                                                            ║
║  DoS Vulnerability Checker v1.1                            ║
║  Teste ético para verificação de segurança                 ║
╚════════════════════════════════════════════════════════════╝
"""

# Endpoints que potencialmente podem causar DoS no Prometheus
VULNERABLE_ENDPOINTS = [
    "/debug/pprof/heap?seconds=5",       # Profiling de heap (consumo de memória)
    "/debug/pprof/profile?seconds=5",    # Profiling de CPU
    "/debug/pprof/block?debug=1",        # Bloqueios de goroutines
    "/debug/pprof/mutex?debug=1",        # Contenção de mutex
    "/debug/pprof/goroutine?debug=2",    # Goroutines com backtrace
    "/api/v1/query?query={__name__=~'.+'}", # Query que retorna todas as métricas
    "/api/v1/query_range?query=up&start=0&end=9999999999&step=1s" # Range query com intervalo enorme
]

# Path para federação que pode causar exaustão de recursos
FEDERATION_PATH = "/federate?match[]={__name__=~'.+'}"

# Métricas de grande volume que podem ser usadas em ataques
HEAVY_METRICS = [
    "prometheus_tsdb_head_series",       # Número de séries temporais
    "go_memstats_alloc_bytes",           # Alocação de memória
    "process_resident_memory_bytes",     # Memória residente
    "scrape_duration_seconds",           # Duração de scrape
    "up",                                # Status dos alvos
    "{__name__=~'.+'}"                   # Todas as métricas (potencialmente pesado)
]

def setup_logging(args):
    """Configura o logger baseado nos argumentos."""
    log_level = logging.DEBUG if args.verbose else logging.INFO
    
    # Configura log para arquivo se solicitado
    if args.log_file:
        logging.basicConfig(
            filename=args.log_file,
            level=log_level,
            format='%(asctime)s - %(levelname)s - %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
    else:
        # Sem log em arquivo, apenas mensagens importantes no console
        logging.basicConfig(
            level=log_level,
            format='%(levelname)s - %(message)s'
        )
    
    # Loga início da execução
    logging.info(f"Iniciando verificação em {args.url}")
    logging.debug(f"Argumentos: {vars(args)}")

def parse_arguments():
    """Parse os argumentos da linha de comando."""
    parser = argparse.ArgumentParser(description='Prometheus DoS Vulnerability Checker')
    parser.add_argument('-u', '--url', required=True, help='URL do servidor Prometheus (ex: http://prometheus:9090)')
    parser.add_argument('-t', '--timeout', type=int, default=10, help='Timeout para requisições em segundos (padrão: 10)')
    parser.add_argument('-c', '--concurrency', type=int, default=3, help='Número de testes concorrentes (padrão: 3)')
    parser.add_argument('-p', '--port-timeout', type=float, default=3.0, help='Timeout para verificação de porta em segundos (padrão: 3.0)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Modo verboso')
    parser.add_argument('--no-banner', action='store_true', help='Não mostrar o banner')
    parser.add_argument('--no-color', action='store_true', help='Desabilitar cores no output')
    parser.add_argument('--log-file', help='Arquivo para salvar logs (ex: prometheus_check.log)')
    parser.add_argument('--username', help='Usuário para autenticação básica')
    parser.add_argument('--password', help='Senha para autenticação básica')
    parser.add_argument('--token', help='Token de autenticação (header Authorization)')
    parser.add_argument('--ignore-ssl', action='store_true', help='Ignorar verificação de certificados SSL')
    parser.add_argument('--rate-limit-test', action='store_true', help='Testar existência de rate limiting')
    parser.add_argument('--output', help='Arquivo de saída para o relatório JSON (padrão: baseado no hostname e timestamp)')
    args = parser.parse_args()
    
    # Valida URL
    try:
        validate_url(args.url)
    except ValueError as e:
        parser.error(str(e))
    
    return args

def validate_url(url):
    """Valida se a URL está em formato correto."""
    parsed = urlparse(url)
    if not parsed.scheme in ('http', 'https') or not parsed.netloc:
        raise ValueError("URL inválida. Use formato como http://prometheus:9090")
    return url

def get_auth_params(args):
    """Prepara parâmetros de autenticação baseados nos argumentos."""
    auth = None
    headers = {}
    
    if args.username:
        auth = (args.username, args.password or "")
        logging.debug("Usando autenticação básica")
    
    if args.token:
        headers['Authorization'] = f"Bearer {args.token}"
        logging.debug("Usando autenticação via token")
    
    return auth, headers

def print_verbose(message, args, level="INFO"):
    """Imprime mensagens em modo verboso e loga."""
    # Sempre loga a mensagem no nível apropriado
    if level == "INFO":
        logging.info(message)
    elif level == "WARNING":
        logging.warning(message)
    elif level == "ERROR":
        logging.error(message)
    elif level == "SUCCESS":
        logging.info(f"SUCESSO: {message}")
    elif level == "DEBUG":
        logging.debug(message)
    
    # Apenas imprime no console se estiver em modo verboso
    if args.verbose:
        if not args.no_color:
            if level == "INFO":
                print(f"{COLOR_BLUE}[i] {message}{COLOR_RESET}")
            elif level == "WARNING":
                print(f"{COLOR_YELLOW}[!] {message}{COLOR_RESET}")
            elif level == "ERROR":
                print(f"{COLOR_RED}[✗] {message}{COLOR_RESET}")
            elif level == "SUCCESS":
                print(f"{COLOR_GREEN}[✓] {message}{COLOR_RESET}")
            elif level == "DEBUG":
                print(f"{COLOR_BLUE}[d] {message}{COLOR_RESET}")
        else:
            print(f"[{level}] {message}")

def test_endpoint(prometheus_url, endpoint, args):
    """Testa um endpoint específico e retorna métricas de desempenho."""
    url = f"{prometheus_url.rstrip('/')}{endpoint}"
    timeout = args.timeout
    auth, headers = get_auth_params(args)
    
    try:
        start_time = time.time()
        response = requests.get(
            url, 
            timeout=timeout,
            auth=auth,
            headers=headers,
            verify=not args.ignore_ssl
        )
        end_time = time.time()
        response_time = end_time - start_time
        
        return {
            "endpoint": endpoint,
            "status_code": response.status_code,
            "response_time": response_time,
            "response_size": len(response.content),
            "successful": 200 <= response.status_code < 400,
            "error": None
        }
    except requests.exceptions.Timeout:
        return {
            "endpoint": endpoint,
            "status_code": None,
            "response_time": timeout,
            "response_size": 0,
            "successful": False,
            "error": "Timeout"
        }
    except requests.exceptions.SSLError as e:
        return {
            "endpoint": endpoint,
            "status_code": None,
            "response_time": time.time() - start_time,
            "response_size": 0,
            "successful": False,
            "error": f"Erro SSL: {str(e)}. Use --ignore-ssl para ignorar."
        }
    except requests.exceptions.RequestException as e:
        return {
            "endpoint": endpoint,
            "status_code": None,
            "response_time": time.time() - start_time,
            "response_size": 0,
            "successful": False,
            "error": str(e)
        }

def check_basic_connectivity(prometheus_url, args):
    """Verifica a conectividade básica com o servidor Prometheus."""
    auth, headers = get_auth_params(args)
    timeout = args.timeout
    
    try:
        start_time = time.time()
        response = requests.get(
            prometheus_url, 
            timeout=timeout,
            auth=auth,
            headers=headers,
            verify=not args.ignore_ssl
        )
        response_time = time.time() - start_time
        
        return {
            "status_code": response.status_code,
            "response_time": response_time,
            "successful": 200 <= response.status_code < 400
        }
    except requests.exceptions.SSLError as e:
        return {
            "status_code": None,
            "response_time": 0,
            "successful": False,
            "error": f"Erro SSL: {str(e)}. Use --ignore-ssl para ignorar."
        }
    except requests.exceptions.RequestException as e:
        return {
            "status_code": None,
            "response_time": 0,
            "successful": False,
            "error": str(e)
        }

def test_rate_limit(prometheus_url, endpoint, args, attempts=10):
    """Verifica se há rate limiting implementado."""
    print_verbose(f"Testando rate limiting em {endpoint} com {attempts} tentativas rápidas", args, "DEBUG")
    
    results = []
    rate_limited = False
    
    for i in range(attempts):
        result = test_endpoint(prometheus_url, endpoint, args)
        results.append(result)
        
        # Consideramos que está rate-limited se receber 429 ou conexões começarem a falhar
        if result["status_code"] == 429:
            rate_limited = True
            print_verbose(f"Detectado rate limiting (429 Too Many Requests) na tentativa {i+1}", args, "SUCCESS")
            break
        
        # Se conexões começarem a falhar depois de algumas tentativas, pode ser rate limiting
        if i > 3 and not result["successful"] and results[i-1]["successful"]:
            rate_limited = True
            print_verbose(f"Possível rate limiting detectado (falhas após tentativas bem-sucedidas)", args, "WARNING")
            break
    
    # Também podemos detectar rate limiting se o tempo de resposta aumentar significativamente
    successful_results = [r for r in results if r["successful"]]
    if len(successful_results) >= 3:
        first_times = [r["response_time"] for r in successful_results[:2]]
        last_times = [r["response_time"] for r in successful_results[-2:]]
        
        avg_first = sum(first_times) / len(first_times)
        avg_last = sum(last_times) / len(last_times)
        
        if avg_last > avg_first * 2:  # Se tempo médio dobrou
            rate_limited = True
            print_verbose(f"Possível rate limiting detectado (tempo de resposta aumentou significativamente)", 
                         args, "WARNING")
    
    return rate_limited

def check_port_security(url, args):
    """Verifica se a porta está aberta para acesso público."""
    parsed_url = urlparse(url)
    hostname = parsed_url.hostname
    port = parsed_url.port or (443 if parsed_url.scheme == 'https' else 80)
    
    try:
        # Verifica se é um IP privado
        addr_info = socket.getaddrinfo(hostname, port)
        ip = addr_info[0][4][0]
        
        is_private = False
        
        # Verifica faixas de IPs privados
        private_ranges = [
            ('10.0.0.0', '10.255.255.255'),       # Classe A
            ('172.16.0.0', '172.31.255.255'),     # Classe B
            ('192.168.0.0', '192.168.255.255'),   # Classe C
            ('127.0.0.0', '127.255.255.255')      # Localhost
        ]
        
        for start, end in private_ranges:
            if ip_to_int(start) <= ip_to_int(ip) <= ip_to_int(end):
                is_private = True
                break
        
        # Tenta conectar ao serviço
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(args.port_timeout)
        result = sock.connect_ex((hostname, port))
        sock.close()
        
        if result == 0:
            if is_private:
                print_verbose(f"Aviso: O servidor {hostname}:{port} está acessível, mas parece ser um IP privado ({ip}).", 
                             args, "WARNING")
                return {"accessible": True, "public": False, "ip": ip}
            else:
                print_verbose(f"Alerta: O servidor {hostname}:{port} está publicamente acessível ({ip}).",
                             args, "WARNING")
                return {"accessible": True, "public": True, "ip": ip}
        else:
            print_verbose(f"O servidor {hostname}:{port} não está acessível de fora.", args, "INFO")
            return {"accessible": False, "public": False, "ip": ip}
    except Exception as e:
        print_verbose(f"Erro ao verificar acessibilidade: {str(e)}", args, "ERROR")
        return {"accessible": False, "public": False, "error": str(e)}

def ip_to_int(ip):
    """Converte um endereço IP para inteiro para facilitar comparações."""
    octets = ip.split('.')
    return int(octets[0]) << 24 | int(octets[1]) << 16 | int(octets[2]) << 8 | int(octets[3])

def test_query_endpoint(prometheus_url, query, args):
    """Testa endpoint de consulta com uma métrica específica."""
    endpoint = f"/api/v1/query?query={query}"
    return test_endpoint(prometheus_url, endpoint, args)

def run_vulnerability_tests(prometheus_url, args):
    """Executa todos os testes de vulnerabilidade."""
    results = {
        "connectivity": {},
        "port_security": {},
        "vulnerable_endpoints": [],
        "query_performance": [],
        "rate_limiting": {},
        "overall_score": 0,
        "issues_found": 0,
        "recommendations": []
    }
    
    # Cores para output
    c_blue = COLOR_BLUE if not args.no_color else ""
    c_green = COLOR_GREEN if not args.no_color else ""
    c_yellow = COLOR_YELLOW if not args.no_color else ""
    c_red = COLOR_RED if not args.no_color else ""
    c_reset = COLOR_RESET if not args.no_color else ""
    
    # Verifica conectividade básica
    print(f"{c_blue}[+] Verificando conectividade com {prometheus_url}...{c_reset}")
    connectivity = check_basic_connectivity(prometheus_url, args)
    results["connectivity"] = connectivity
    
    if not connectivity["successful"]:
        print(f"{c_red}[✗] Falha ao conectar ao servidor Prometheus! {connectivity.get('error', '')}{c_reset}")
        return results
    
    print(f"{c_green}[✓] Servidor Prometheus respondendo! (Tempo de resposta: {connectivity['response_time']:.2f}s){c_reset}")
    
    # Verifica segurança da porta
    print(f"{c_blue}[+] Verificando acessibilidade do servidor...{c_reset}")
    port_security = check_port_security(prometheus_url, args)
    results["port_security"] = port_security
    
    if port_security.get("public", False):
        print(f"{c_red}[✗] ALERTA: Servidor Prometheus publicamente acessível em {port_security.get('ip', 'unknown')}!{c_reset}")
        results["issues_found"] += 1
        results["recommendations"].append("Restrinja o acesso ao Prometheus usando firewall ou proxy reverso com autenticação.")
    
    # Testa endpoints vulneráveis
    print(f"{c_blue}[+] Testando endpoints potencialmente vulneráveis a DoS...{c_reset}")
    endpoints_results = []
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.concurrency) as executor:
        future_to_endpoint = {
            executor.submit(test_endpoint, prometheus_url, endpoint, args): endpoint
            for endpoint in VULNERABLE_ENDPOINTS
        }
        
        for future in concurrent.futures.as_completed(future_to_endpoint):
            endpoint = future_to_endpoint[future]
            try:
                result = future.result()
                endpoints_results.append(result)
                
                if result["successful"]:
                    print(f"{c_yellow}[!] Endpoint vulnerável acessível: {endpoint} "
                          f"(Tempo: {result['response_time']:.2f}s, Tamanho: {result['response_size']} bytes){c_reset}")
                    results["issues_found"] += 1
                else:
                    print_verbose(f"Endpoint protegido ou não disponível: {endpoint} "
                                 f"({result.get('error', 'Status: ' + str(result['status_code']))})", args, "INFO")
            except Exception as exc:
                print_verbose(f"Erro ao testar {endpoint}: {exc}", args, "ERROR")
    
    results["vulnerable_endpoints"] = endpoints_results
    
    # Testa endpoint de federação
    fed_result = test_endpoint(prometheus_url, FEDERATION_PATH, args)
    if fed_result["successful"]:
        print(f"{c_yellow}[!] Endpoint de federação acessível e não protegido!{c_reset}")
        results["issues_found"] += 1
        results["recommendations"].append("Desative ou proteja o endpoint de federação (/federate) quando não estiver em uso.")
        results["vulnerable_endpoints"].append(fed_result)
    
    # Testa consultas potencialmente pesadas
    print(f"{c_blue}[+] Testando consultas potencialmente pesadas...{c_reset}")
    query_results = []
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.concurrency) as executor:
        future_to_query = {
            executor.submit(test_query_endpoint, prometheus_url, query, args): query
            for query in HEAVY_METRICS
        }
        
        for future in concurrent.futures.as_completed(future_to_query):
            query = future_to_query[future]
            try:
                result = future.result()
                query_results.append(result)
                
                # Baseamos a severidade no tempo de resposta e tamanho dos dados
                severity_factor = result["response_time"] * (result["response_size"] / 1000000 + 1)
                
                if result["successful"] and severity_factor > 2.0:
                    print(f"{c_red}[!] Consulta pesada acessível: {query} "
                          f"(Tempo: {result['response_time']:.2f}s, Tam: {result['response_size']/1000:.1f}KB){c_reset}")
                    results["issues_found"] += 1
                elif result["successful"] and result["response_time"] > 1.0:
                    print(f"{c_yellow}[!] Consulta potencialmente pesada acessível: {query} "
                          f"(Tempo: {result['response_time']:.2f}s){c_reset}")
                    results["issues_found"] += 1
                elif result["successful"]:
                    print_verbose(f"Consulta acessível mas com resposta rápida: {query} "
                                 f"(Tempo: {result['response_time']:.2f}s)", args, "INFO")
            except Exception as exc:
                print_verbose(f"Erro ao testar consulta {query}: {exc}", args, "ERROR")
    
    results["query_performance"] = query_results
    
    # Verifica recursos do endpoint /metrics
    try:
        metrics_result = test_endpoint(prometheus_url, "/metrics", args)
        if metrics_result["successful"] and metrics_result["response_size"] > 500000:
            print(f"{c_yellow}[!] Endpoint /metrics retorna grande volume de dados "
                  f"({metrics_result['response_size']/1000000:.2f} MB){c_reset}")
            results["issues_found"] += 1
            results["recommendations"].append("Considere limitar ou proteger o endpoint /metrics para evitar vazamento de dados.")
    except Exception as e:
        print_verbose(f"Erro ao verificar endpoint /metrics: {e}", args, "ERROR")
    
    # Teste de rate limiting
    if args.rate_limit_test:
        print(f"{c_blue}[+] Testando implementação de rate limiting...{c_reset}")
        # Testar rate limiting em um endpoint que conhecidamente existe (por exemplo, /metrics)
        rate_limited = test_rate_limit(prometheus_url, "/metrics", args)
        results["rate_limiting"] = {
            "implemented": rate_limited,
            "endpoint_tested": "/metrics"
        }
        
        if rate_limited:
            print(f"{c_green}[✓] Rate limiting detectado - boa proteção contra DoS!{c_reset}")
            results["recommendations"].append("Rate limiting detectado, isso é positivo para proteção contra DoS.")
        else:
            print(f"{c_yellow}[!] Rate limiting não detectado - servidor vulnerável a ataques de sobrecarga.{c_reset}")
            results["issues_found"] += 1
            results["recommendations"].append("Implementar rate limiting para evitar ataques de sobrecarga.")
    
    # Calcula pontuação geral (de 0 a 10, onde 0 é mais seguro)
    # Fatores com pesos mais dinâmicos:
    
    # 1. Exposição pública: +3 pontos
    score = 0
    if port_security.get("public", False):
        score += 3
    
    # 2. Endpoints vulneráveis: peso dinâmico baseado em tempo de resposta
    vulnerable_endpoints = [r for r in results["vulnerable_endpoints"] if r["successful"]]
    for endpoint in vulnerable_endpoints:
        # Quanto mais lento o endpoint responder, maior o peso na vulnerabilidade
        response_factor = min(endpoint["response_time"] / 2, 2.0)  # Limita a 2.0
        score += 0.5 + response_factor  # Base 0.5 + fator de resposta
    
    # 3. Endpoint de federação exposto: +2 pontos
    if any(r["endpoint"] == FEDERATION_PATH for r in results["vulnerable_endpoints"] if r["successful"]):
        score += 2
    
    # 4. Consultas lentas: peso dinâmico baseado em tempo e tamanho
    for query in results["query_performance"]:
        if query["successful"]:
            # Combina tempo de resposta e tamanho para o peso
            severity = query["response_time"] * (query["response_size"] / 1000000 + 1) / 4
            score += min(severity, 1.5)  # Limita a 1.5 por consulta
    
    # 5. Sem rate limiting: +2 pontos
    if args.rate_limit_test and not results["rate_limiting"].get("implemented", False):
        score += 2
    
    # Limita score entre 0 e 10
    results["overall_score"] = min(10, score)
    
    # Adiciona recomendações gerais
    if vulnerable_endpoints:
        results["recommendations"].append("Proteja todos os endpoints de debug (/debug/pprof/*) usando regras de firewall ou proxy reverso.")
    
    slow_queries = [r for r in results["query_performance"] if r["successful"] and r["response_time"] > 1.0]
    if slow_queries:
        results["recommendations"].append("Implemente rate limiting para consultas à API.")
        results["recommendations"].append("Considere adicionar cache para consultas frequentes.")
    
    if port_security.get("public", False):
        results["recommendations"].append("Configure autenticação usando proxy reverso (NGINX, Apache, etc).")
        results["recommendations"].append("Se possível, coloque o Prometheus em uma rede privada, acessível apenas via VPN.")
        results["recommendations"].append("Considere usar ferramentas como Grafana para visualização, expondo apenas a interface de usuário.")
    
    # Aviso sobre limitações do teste
    results["limitations"] = [
        "Este teste realiza verificações leves que podem não refletir o comportamento sob carga real.",
        "Um servidor que parece seguro neste teste ainda pode ser vulnerável a ataques mais intensos ou sofisticados.",
        "Recomenda-se complementar esta análise com testes de carga controlados em ambiente de testes."
    ]
    
    return results

def print_report(results):
    """Imprime um relatório com os resultados e recomendações."""
    score = results["overall_score"]
    issues = results["issues_found"]
    
    # Define cores ou strings vazias se cores desativadas
    args = parse_arguments()
    c_blue = COLOR_BLUE if not args.no_color else ""
    c_green = COLOR_GREEN if not args.no_color else ""
    c_yellow = COLOR_YELLOW if not args.no_color else ""
    c_red = COLOR_RED if not args.no_color else ""
    c_reset = COLOR_RESET if not args.no_color else ""
    
    print("\n" + "=" * 70)
    print(f"{c_blue}RELATÓRIO DE VULNERABILIDADE A DoS - PROMETHEUS{c_reset}")
    print("=" * 70)
    
    # Status geral
    if score < 3:
        risk_level = f"{c_green}BAIXO{c_reset}"
    elif score < 6:
        risk_level = f"{c_yellow}MÉDIO{c_reset}"
    else:
        risk_level = f"{c_red}ALTO{c_reset}"
    
    print(f"\nÍndice de Vulnerabilidade: {risk_level} ({score:.1f}/10)")
    print(f"Problemas encontrados: {issues}")
    
    # Detalhes
    print("\n" + "-" * 70)
    print(f"{c_blue}DETALHES ENCONTRADOS:{c_reset}")
    print("-" * 70)
    
    if results["port_security"].get("public", False):
        print(f"{c_red}[✗] Servidor publicamente acessível no IP {results['port_security'].get('ip', 'desconhecido')}{c_reset}")
    
    # Endpoints vulneráveis
    vulnerable_endpoints = [r for r in results["vulnerable_endpoints"] if r["successful"]]
    if vulnerable_endpoints:
        print(f"\n{c_yellow}Endpoints vulneráveis a DoS encontrados:{c_reset}")
        for endpoint in vulnerable_endpoints:
            print(f"  - {endpoint['endpoint']} (Tempo: {endpoint['response_time']:.2f}s)")
    
    # Rate limiting
    if "rate_limiting" in results and results["rate_limiting"]:
        has_ratelimit = results["rate_limiting"].get("implemented", False)
        if has_ratelimit:
            print(f"\n{c_green}[✓] Rate limiting detectado - boa proteção!{c_reset}")
        else:
            print(f"\n{c_yellow}[!] Rate limiting não implementado ou não detectado{c_reset}")
    
    # Recomendações
    print("\n" + "-" * 70)
    print(f"{c_blue}RECOMENDAÇÕES:{c_reset}")
    print("-" * 70)
    
    if not results["recommendations"]:
        print("Nenhuma recomendação específica. Continue monitorando seu servidor.")
    else:
        for i, rec in enumerate(results["recommendations"], 1):
            print(f"{i}. {rec}")
    
    # Limitações do teste
    print("\n" + "-" * 70)
    print(f"{c_yellow}LIMITAÇÕES DESTE TESTE:{c_reset}")
    print("-" * 70)
    for limitation in results.get("limitations", []):
        print(f"- {limitation}")
    
    print("\n" + "=" * 70)
    print(f"{c_blue}PROMETHEUS DoS VULNERABILITY CHECKER{c_reset}")
    print(f"Relatório gerado em: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 70 + "\n")

def export_json_report(results, prometheus_url, output_file=None):
    """Exporta os resultados em formato JSON."""
    if output_file:
        filename = output_file
    else:
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        hostname = urlparse(prometheus_url).netloc.replace(":", "_")
        filename = f"prometheus_dos_check_{hostname}_{timestamp}.json"
    
    try:
        with open(filename, "w") as f:
            json.dump({
                "target": prometheus_url,
                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                "results": results
            }, f, indent=2)
        
        print(f"Relatório JSON salvo em: {filename}")
        logging.info(f"Relatório JSON exportado para {filename}")
        return filename
    except Exception as e:
        error_msg = f"Erro ao salvar relatório JSON: {str(e)}"
        print(f"{COLOR_RED if not args.no_color else ''}[✗] {error_msg}{COLOR_RESET if not args.no_color else ''}")
        logging.error(error_msg)
        return None

def main():
    """Função principal."""
    args = parse_arguments()
    
    # Desabilitar cores se requisitado
    if args.no_color:
        global COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_BLUE, COLOR_RESET
        COLOR_RED = COLOR_GREEN = COLOR_YELLOW = COLOR_BLUE = COLOR_RESET = ""
    
    # Configurar logging
    setup_logging(args)
    
    # Exibir banner
    if not args.no_banner:
        print(BANNER)
    
    print(f"{COLOR_BLUE if not args.no_color else ''}[+] Iniciando verificação de vulnerabilidade a DoS em {args.url}{COLOR_RESET if not args.no_color else ''}")
    print(f"{COLOR_BLUE if not args.no_color else ''}[+] Timeout: {args.timeout}s, Concorrência: {args.concurrency}{COLOR_RESET if not args.no_color else ''}")
    
    # Exibir aviso sobre testes
    print(f"{COLOR_YELLOW if not args.no_color else ''}[!] AVISO: Esta ferramenta realiza apenas testes leves para detectar vulnerabilidades.{COLOR_RESET if not args.no_color else ''}")
    print(f"{COLOR_YELLOW if not args.no_color else ''}[!] Um sistema que parece seguro ainda pode ser vulnerável sob carga real.{COLOR_RESET if not args.no_color else ''}")
    
    try:
        results = run_vulnerability_tests(args.url, args)
        print_report(results)
        export_json_report(results, args.url, args.output)
        
        # Exibe mensagem final baseada na pontuação
        score = results["overall_score"]
        if score >= 7:
            print(f"{COLOR_RED if not args.no_color else ''}[!] ALERTA! Seu servidor Prometheus tem vulnerabilidades sérias a ataques DoS.{COLOR_RESET if not args.no_color else ''}")
            print(f"{COLOR_RED if not args.no_color else ''}[!] Implemente as recomendações urgentemente!{COLOR_RESET if not args.no_color else ''}")
        elif score >= 4:
            print(f"{COLOR_YELLOW if not args.no_color else ''}[!] Seu servidor Prometheus tem vulnerabilidades moderadas a ataques DoS.{COLOR_RESET if not args.no_color else ''}")
            print(f"{COLOR_YELLOW if not args.no_color else ''}[!] Considere implementar as recomendações sugeridas.{COLOR_RESET if not args.no_color else ''}")
        else:
            print(f"{COLOR_GREEN if not args.no_color else ''}[✓] Seu servidor Prometheus parece relativamente bem protegido contra ataques DoS simples.{COLOR_RESET if not args.no_color else ''}")
            print(f"{COLOR_GREEN if not args.no_color else ''}[✓] Continue monitorando e aplicando boas práticas de segurança.{COLOR_RESET if not args.no_color else ''}")
        
    except KeyboardInterrupt:
        msg = "Verificação interrompida pelo usuário."
        print(f"\n{COLOR_RED if not args.no_color else ''}[!] {msg}{COLOR_RESET if not args.no_color else ''}")
        logging.warning(msg)
        sys.exit(1)
    except Exception as e:
        msg = f"Erro durante a verificação: {str(e)}"
        print(f"\n{COLOR_RED if not args.no_color else ''}[✗] {msg}{COLOR_RESET if not args.no_color else ''}")
        logging.error(msg, exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"Erro fatal: {str(e)}")
        logging.critical(f"Erro fatal: {str(e)}", exc_info=True)
        sys.exit(1)